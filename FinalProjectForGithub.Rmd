---
title: "FinalProject2"
author: "Rowan R"
date: "06/04/2022"
output:
  html_document:
    df_print: paged
  pdf_document: default
  word_document: default
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## R Markdown

embed an R code chunk like this:

It is helpful to create a project directory using file, new project, new project again, then select a convenient location on your computer. Once a project folder has been created, put this R markdown file into it along with the data file, open the project then open this R markdown file. Then check the working directory is set to the project directory.
```{r, eval =FALSE}
#then set working directory to appropriate location containing the data file
getwd() #check your working directory is set to the project directory, if not specify below or select session, set working directory, to project directory
#setwd("yourdirhere")

```
Next, install packages required for data manipulation (tidyverse), for network analysis (bipartite). We will install the packages for visualisation later.
```{r, eval=FALSE}
install.packages("tidyverse") #install packages required
install.packages("bipartite", dependencies = TRUE) #packages only need to be installed once
```
After installing, packages need to be loaded.
```{r, message=FALSE,warning=FALSE}
#after installing, load packages using library to make them available for use
library(tidyverse)
library(bipartite)
library(bipartiteD3)
#then clear the workspace
rm(list = ls(all = T))
```

Data Import - using the tidyverse for efficiency. The tidyverse is a group of
packages that act in similar ways. Many base R functions have a tidyverse counterpart. When importing data, the tidyverse uses tibbles instead of data frames. Also, the tidyverse (dplyr) read functions do not auto convert data types (i.e. strings as factors), and also don't require header=TRUE, they assume the first row is column names. 

```{r, message=FALSE}
rawdata<- read_csv("2021CamasDataFinalProj.csv") #read in file, using a file type that matches the read function (csv)
rawdata #another tibble quirk: prints first 10 rows only when called, although this doesn't work so well in a markdown document
#to see all the variables, use str(rawdata) or view all variables and observations using view(rawdata)
```

What is this raw data? 

This is a data set of pollinators collected on various plants in meadows.
Each observation is one record of a pollinator, with associated information like the location of collection, the flower it was collected on, plus the species and genus identity of the pollinator and more.

Having a list of taxa present is often useful, it may also be asked for when writing reports or providing to government or conservation organizations. 

```{r}
unique(rawdata$Genus) #get a list of unique pollinator genera, note that for reporting, we would want to remove the NA, but we will do that more elegantly later. We're not getting a species list right now because the species is currently a single column and there are no latin binomials yet
```

Getting raw data ready for analysis.

Incoming data is often not R friendly, and tends to need some cleaning up before use in analyses. Luckily in this data each observation is contained in one row, which is the type of data (called tidy data) that tidyverse functions are designed to work optimally with. We can use tidyverse functions to make modifications to the data that are necessary to work with network functions. In the tidyverse, multiple operations can be combined into a few lines of code using the pipe operator ( %>% ). The pipe operator can be thought of as 'then do', so we can take our data then do (%>%) the next function. The following is an introductory example of a one step process, choosing only the rows that have an identified pollinator, in this case all of the bees. This is done by keeping only rows that do not have a missing value in the Genus column, an NA means that the insect was not identified (in this data set missing rows are insects that were not bees)
```{r}
beesonly<- rawdata %>% #get data then: 
  filter(!is.na(Genus)) #keep only rows that do not have a missing value in the Genus column. 
```
Real data also tends to have errors. These can be fixed in Excel, but when values occur in multiple locations or more than one mistake needs to be corrected, it makes sense to fix them in R. The tidyverse function mutate can be used to create new variables, or replace existing variables with updated ones. Many functions can be used within mutate, such as recode, which takes as arguments: a column, the value that should be replaced, then the value that is to replace it. 
```{r}
beesonly<- beesonly %>% 
  mutate(species = recode(species, "Nuda" = "nuda")) %>% #replacing capitalized species name with uncapitalized species name, then
mutate(species = recode(species, "perhirta" = "perihirta")) #fixing an "i" that was missed during data entry
```
Now that we have selected our bees/real values and their names are correct, we have another issue. We can see in the data that the bee species names are currently separated into genus and species columns, and bipartite network functions require a single column or row for each organism name. We can combine a genus and species column into one column which will be done below using the unite function. The arguments are: Name of new column, range of columns to combine (in this case they are next to each other in the data frame so the : means from genus column to species), then what to separate the values by, in this case a single space.  
```{r}
beesonly<- beesonly%>% 
  unite("BeeName", Genus:species, sep = " ") #unite two columns into one
head(beesonly$BeeName) #check the output looks okay
```
Now that we have data that include the variables necessary to make bipartite networks, we can select some variables of interest out of the many that were included. Our required ones include associated taxa, which are the plants bees were caught on, the bee species, then we have things we might want to explore later on like site (aka Code), elevation or sampling round.
```{r}
beesonly<- beesonly %>% #take data then:
  select(associated_taxa,BeeName,Code,date,Round,`Elevation_(m)`,specimen)
#select columns of interest: plants and bees, site code, date, round of sampling, elevation, whether a specimen was collected or not 
```
As mentioned above, some functions require different formats, such as matrices. For example, bipartite, the network analysis package requires a matrix with plant names in the first column, then each pollinator species as its own column, with each row the number of interactions between each plant and pollinator combination. 

As is, the data is all individual observations, it needs to be converted into the above form, where each plant-pollinator interaction has a count. This can be done using the dplyr functions group_by and summarise. group_by allows functions further down the pipe to act on groups of rows that share values of a certain column instead of simply all rows. Summarise does what it says, it provides a single number average, or counts, or standard deviations of a group of rows. Together group by and summarise can provide summaries of groups, which is what we want: a group for every plant-pollinator interaction, and a count of how many times that interaction occurred. Below we will group_by flowering plant and bee species, then summarise number of times that combo occurred.
```{r}
beesperflower<- beesonly %>% #get data set then
group_by(associated_taxa,BeeName) %>% # group by flowering plant and bee species, then
  summarise(n = n()) #summarise the number in each group, newvariablename = function()

head(beesperflower) #examine new data, note each row is a plant-pollinator interaction with a count n. 
```

We still aren't at a matrix yet, we need to have one row for each plant, with each bee species as a column name. We can turn the current 'tidy' data into a matrix by using a pivot function. pivot_wider takes data within a column and turns each unique value into its own column, with the values for each new column coming from another specified column. In this and most data destined for network analysis, not every combination will exist. Another way to think of this is that each plant will not necessarily have an interaction with every pollinator. In R, a pivot function will not know this, and by default will fill such non-existing (or non-detected) interactions with NAs, when they should be zeroes. Luckily pivot_wider takes an argument called values_fill to fill unknown values (NAs) with a specified value (0 in this case). bipartite also requires plant names to be row names instead of an actual column, so the last step converts the associated taxa column to row names. 
```{r}
interactmatrix <- beesperflower %>% #then do: 
  pivot_wider(names_from = BeeName, #pivot wider, get column names from species column
    values_from = n, values_fill = 0)  %>%   # numbers from n column, fill NAs with 0, then
  column_to_rownames(.,var = "associated_taxa") #make the first column using the data from above (the . indicates this) into row names
```

Now we can use the standard network package (bipartite) to get some network metrics for the matrix. Note these may take some time to run. The output of species level is a list containing each "level" of the network. The two levels are the two types of organisms being compared, in this case plants and pollinators. The first level in the list is the pollinators, or the columns. The second in the list is the plants, or the rows. Many of these metrics are complex, and are better described in a statistical or mathematical tutorial. For now, it is important to note that we can get metrics for each species using species level, as well as for the whole network using network level. One simple per species metric is degree, which represents the number of species in the opposite level that the given species interacts with. For example, in plant metrics below, Allium cernuum has a degree of 10, which means it interacted with 10 species of pollinators. For whole network, some simple metrics include number of species LL and HL (lower level and higher level), which are plants and pollinators respectively, as well as an average number of "links per species". 
```{r}
bispp<- specieslevel(interactmatrix) #can get metrics for each of the species
(pollmetrics<- bispp[[1]]) #gets the pollinator metrics
(plantmetrics <- bispp[[2]]) #gets the plant metrics

binet <- networklevel(interactmatrix) #whole network matrix
binet

```
Knowing how to get the metrics above is important, but not the main focus of this tutorial. Instead, we are going to focus on visualization. bipartite itself provides a function to represent networks visually, which is called plotweb. Shown below, it does not provide very pleasant output by default, and the options to adjust it are not immediately intuitive. It also doesn't appear possible to highlight (selectively colour) certain plant or pollinator species, which is important when working with more complex networks such as the one plotted below.  
```{r}
plotweb(interactmatrix)
```
As above, there's room to improve the network plots, which is what the package bipartiteD3 does. It makes an interactive html network using more modern looking graphical functions. We will install the required packages below and then load them. 
```{r, eval = FALSE}
install.packages("bipartiteD3", dependencies = TRUE) #install package plus all packages it depends on
install.packages("r2d3",dependencies = TRUE)
install.packages("RColorBrewer",dependencies = TRUE)
```

```{r, message=FALSE,warning=FALSE}
library(r2d3)
library(RColorBrewer)
library(bipartiteD3)
```

bipartiteD3 by default does not use a matrix like bipartite, so unfortunately we can't just plug the matrix back in. It instead uses data in a tidy format, which is what we started with before converting into a matrix (starting at line 77). We could go get the data from that intermediate step, or we can use the inverse of pivot_wider, pivot_longer. It works in the opposite way, taking many columns and making them into variables within one column, and storing their values in a second column. First we need to get our row names back into a column, then we can pivot longer, then finally we can remove the 0s we introduced in the matrix, although bipartiteD3 doesn't require them to be removed.
```{r}
d3interactions<- interactmatrix %>% 
  rownames_to_column(var = "associated_taxa") %>% #make a column named associated_taxa out of the row names, then
  pivot_longer(cols = `Andrena sigmundi`:`Hylaeus annulatus`,names_to = "BeeName", values_to = "n") %>% # take all the columns from the first to the last, then put the names in a column named BeeName, and the values in a column named n, then
  filter(n >0) #remove the zeroes, they aren't needed in bipartiteD3
head(d3interactions, n = 5) # first species from data we just created using the interaction matrix
head(beesperflower, n = 5) # first species from data that was used to create the interaction matrix earlier
```

We now have our data back in a format that bipartiteD3 understands, which is first column = interaction partner 1, second column = interaction partner 2, and third column = number of interactions. Lets start out simple, we'll take the first 30 rows of data and make a network with it. 
```{r}
d3interactions %>% 
  slice_head(n = 30) %>% #take the first 30 rows, then
  bipartite_D3(.) # make a network plot using the defaults, note this only works using the . because the first argument to bipartite_D3 is "data ="
```

```{r, eval=FALSE, echo=FALSE, fig.cap="A caption", out.width = '100%'}
knitr::include_graphics("intplot1.png")
```

Now it looks pretty nice and if you run this yourself in R, the figure can be interacted with by hovering over the bar for each pollinator or plant, to show what species that plant or pollinator interacted with. Note: If desired, the rmd can be knit to an html which will include the interactive versions, this pdf includes static screenshots. I have made the knitted html version available on my github account at "link" as well. 

This figure isn't perfect though, even with this small subset of data. We don't have any labels, just primary, secondary and n. These labels can be set using the following: PrimaryLab for the left side name, SecondaryLab for the right side name, and SiteNames sets a value for the n column (which can effectively be used as a title).

There is one other issue, and that is that the percentages of the bees are cut off. This requires some fiddling with MainFigSize and possibly IndivFigSize. Both take c(width,height). In this case it's fairly clear we need to make the main figure wider, so lets change this below, which will can take some trial and error.
```{r}
d3interactions %>% 
  slice_head(n = 30) %>% #get first 30 rows, then
  bipartite_D3(.,PrimaryLab = "Plants", #make the network with left label: plants,
  SecondaryLab = "Bees", #right label: bees
  SiteNames = "First 30", # title: first 30
  MainFigSize = c(850,500)#make main figure 850 wide, 500 in height
 ) #This ends up much better, now we can see all the species names and percentages.
```

```{r, eval=FALSE, echo=FALSE, fig.cap="A caption", out.width = '100%'}
knitr::include_graphics("janky.png")
```

Now that we've made an introductory example, lets get a bit more complex. Say we only had money to get the bumblebees (Bombus spp.) identified, or a conservation organization wanted a visualization of the diversity of bumblebee interactions present. The way to do this would be to take the d3 interaction data, and filter it by any beenames that match bombus. We will do this below using filter and grepl and then make the resulting figure.

```{r}
d3bombus<- d3interactions %>% 
  filter(grepl("Bombus",BeeName))

bipartite_D3(d3bombus,
  PrimaryLab = "Plants", #make the network with left label: plants
  SecondaryLab = "Bombus spp.", #right label: bees
  SiteNames = "Bumble Bee Network", # make a title
  MainFigSize = c(850,500)) #make the figure size the same as before
```
```{r,eval=FALSE, echo=FALSE, fig.cap="A caption", out.width = '100%'}
knitr::include_graphics("bombus.png")
```

That was easy, and our figure size was even about right. From this figure, we can see bumblebees are what would be called generalists, because they do not visit only one flower (this would be referred to as specialized), and instead tend to visit many flowers.

Now what if we want to compare sites, or times of year within our data? In the beesonly data, we have options to examine these questions. We can filter by the Code (site) variable, or by Round (sites were visited in 5 "rounds" within a week or so). Lets try by round first, say we consider rounds 1 and 2 early season, and rounds 3 - 5 late season. 

We can accomplish this is in two ways, either by plotting them separately in two different figures, or by plotting them side by side in one figure. We will start with two different figures. First the data needs to be split into these two groups. One way to achieve this is demonstrated below, using a for loop to go through all the data and split it into two data frames where round either matches 1 or 2 (early season), or 3 to 5 (late season).
```{r}
earlybeesloop <- NULL #set up empty data frames for use later in loop
latebeesloop <- NULL
for(i in 1:length(beesonly$Round)){ #set up number to loop through using data
if (beesonly$Round[i] %in% c(1:2) == TRUE) #if statement, checks whether each loop cycle's Round value matches the early rounds 1 & 2
{int<- beesonly[i,] #if it does, then this code grabs the whole row
earlybeesloop <- rbind(earlybeesloop,int)} #then adds it to a new data frame for early season observations
else if(beesonly$Round[i] %in% c(3:5) == TRUE){ #then if the first if statement wasn't true (Round not = 1 or 2), then this one checks if each loop cycle's Round value matches the late season rounds (3 to 5) 
intlate <- beesonly[i,]# if it matches,this code grabs the whole row
latebeesloop <- rbind(latebeesloop,intlate) #then adds it to a data frame for late season observations. 
}
}

```
Or, this can be done more easily in the tidyverse by filtering observations that match Round = 1 or 2, or 3 to 5.
```{r}
earlybees<- beesonly %>% filter(Round %in% c(1,2)) # make data frame containing observations with a Round value that matches 1 or 2
latebees <- beesonly %>% filter(Round %in% c(3:5))# make data frame containing observations with a Round value that matches 3 to 5
```
So now our data is split into two, and can be made into two separate networks after converting the data into the required format, as above. Because this is going to be done repeatedly, I'm going to create a custom function to do it faster, called tod3. I'll make the early season network below.

```{r}
tod3 <- function(data,...) #function takes argument data and ... to add the possibility of other grouping variables later
{
d3ready <- data %>% #make a data frame from the following process
  group_by(associated_taxa,BeeName,...) %>% #group by plants and bees plus maybe more later
  summarise(n = n()) #count the number of times this interaction occurred
return(d3ready) #output the data frame created
}
```
```{r}
tod3(earlybees) %>% #use function as above to make data then
  bipartite_D3(., #use incoming data make a network
  PrimaryLab = "Plants", #with left label: plants
  SecondaryLab = "Bees", #right label: bees
  SiteNames = "Early Season Network", # make a title
  MainFigSize = c(850,1500) #set the figure 3x > previous
  )
```
```{r, eval=FALSE,  echo=FALSE, fig.cap="A caption", out.width = '100%'}
knitr::include_graphics("earlyd3.png")
```
Now this has some problems. Most of the figure is cut off, so we need to increase the height (shown fixed above). However, increasing the height doesn't fix all the problems. The bars are missing, and the lines drawn don't match the bees and plants very well. To fix this, we mostly need to adjust the IndivFigSize, using c(width,height). Width can be though of as the length of the line, or space between the plants and pollinators in the figure. This can be useful to increase if the lines are too cramped within a narrow space. Height can be thought of as the thickness of the lines, and also as the amount of vertical space each bar occupies. Somewhat counter-intuitively, in more complex graphs it's usually necessary to increase the height, or make bars occupy more vertical space. This is because some bars need a large amount of space to show all of the lines that are coming to them. After these adjustments it tends to be necessary to resize the main figure to match. 

We may have also reached a level of complexity that requires non-alphabetical sorting of the species names. One way to do this is to sort by the number of individuals per interaction, grouping by the level of interest (plants or bees, then summarising n, arranging the data frame by the summary, then extracting the names). I have built a custom function to do this, called namesort, that takes the data plus the column name for plants or bees and orders the names from most to least interactions.
```{r}             
earlybeesdat<- tod3(earlybees) #make data into form ready for d3 (plus the function below)

namesort<- function(data,netlev){ #make function that takes data, netlev (network level) arguments
  df1<- data %>% #make a data frame that is:
    group_by(!!ensym(netlev)) %>% #grouped by the desired network level (netlev), the !!ensym is necessary when working with tidyverse functions so that they don't read netlev as netlev and instead as what netlev is set to
    summarise(n1 = sum(n)) %>% #count total per species, assumes n is the count variable name
    arrange(desc(n1)) #arrange in descending order
  df1 <- df1 %>% #get only sorted names
    select(.,!!ensym(netlev)) #selecting the variable that was grouped by, again using the tidyverse friendly variable name
  return(df1)#output the sorted names
}
``` 
Now we have a function to sort names, we can make the early network with sorted names to make it clearer, using the SortPrimary and SortSecondary arguments. We'll also make other improvements discussed above, mainly adjusting IndivFigSize and MainFigSize. 

```{r}
beesorted<- namesort(data = earlybeesdat, netlev = BeeName) #use function to sort bee names
plantsort <- namesort(earlybeesdat, associated_taxa) #use function to sort plant names`

  bipartite_D3(earlybeesdat, #using the incoming data make a network
  PrimaryLab = "Plants", #with left label: plants
  SecondaryLab = "Bees", #right label: bees
  SiteNames = "Early Season Network",# make a title
  MainFigSize = c(1450,1800), #adjusted based on IndivFigSize
  IndivFigSize = c(400,1500),#Increase height substantially until all bars visible, increase width if desired to ease congestion of lines
  SortPrimary = plantsort$associated_taxa, #sort from high to low, plants
  SortSecondary = beesorted$BeeName,#sort from high to low, bees
  Pad = 1.1) #sets minimum space between each plant or pollinator name
```
```{r, eval=FALSE, echo=FALSE, fig.cap="A caption", out.width = '100%'}
knitr::include_graphics("early2.png")
```
We've reached a fairly complex network at this point. It might be a good idea to highlight an interaction or species of interest. This can be done using the HighlightLab and HighlightCol arguments. These take a species name and colour name, respectively. Let's say we want to know which plants the bee species Ceratina acantha visits, we can highlight it and get an idea of which plants it visits, and an approximate proportion of the visits it makes up for each of those plants. 
```{r}
 bipartite_D3(earlybeesdat, #using the incoming data make a network
  PrimaryLab = "Plants", #with left label: plants
  SecondaryLab = "Bees", #right label: bees
  SiteNames = "Early Season Network",# make a title
  MainFigSize = c(1450,1800), #adjusted based on IndivFigSize
  IndivFigSize = c(400,1500),#Increase height substantially until all bars visible, increase width if desired to ease congestion of lines
  SortPrimary = plantsort$associated_taxa, #sort from high to low, plants
  SortSecondary = beesorted$BeeName,#sort from high to low, bees
  Pad = 1.1, #space between adjacent species names
  HighlightLab = "Ceratina acantha", #highlight the species named
  HighlightCol = "darkgreen") #colour the species (chosen because the bee is dark green)
```
```{r, eval = FALSE, echo=FALSE, fig.cap="A caption", out.width = '100%'}
knitr::include_graphics("")
```

We can also colour the whole network by either the pollinator species, or the plant species. It would likely make sense to colour by the one with fewer species, as it becomes increasingly difficult to choose distinct colours the more species there are. Even the graph above is likely too complex to choose distinct colours for. 

I'll use the bombus example from above and colour the bumblebees because there are only 9 species. bipartite_D3 has three options for choosing colours, set by Colouroption:
1. "monochrome", which we've used so far
2. "manual", allows the user to provide a list of colours to another argument (NamedColourVector). Be sure to provide enough colours so that colours are not repeated for different species. 

3. "brewer", uses preset groups of colours (called palettes) from the R package RColorBrewer. These can be found online, and in bipartite_D3 the BrewerPalette argument allows one to be chosen. In the bumblebee data we have 9 species, so if we use the default palette in bipartite_D3 which only has 8 colours, one repeats. Instead, we can find a palette with 9 or more, such as Set1. 
```{r}
d3bombus<- d3interactions %>% 
  filter(grepl("Bombus",BeeName))

bipartite_D3(d3bombus,
  PrimaryLab = "Plants", #make the network with left label: plants
  SecondaryLab = "Bombus spp.", #right label: bees
  SiteNames = "Bumble Bee Network", # make a title
  MainFigSize = c(850,500), #set figure size
  ColourBy = 2, #choose right or left side to colour (1 = left, 2 = right)
  colouroption = "brewer", #Choose between monochrome (default), brewer palettes, and manual palettes (you provide a list of colours) 
  BrewerPalette = "Set1") #choose brewer palette
```
```{r, eval=FALSE, echo=FALSE, fig.cap="A caption", out.width = '100%'}
knitr::include_graphics("bombcol.png")
```
Now that we know how to make single networks and get them to appear okay, we can move on to making multiple networks within the same graph to see how networks differ at different times or locations. This should be accompanied by quantitative analysis before drawing any strong conclusions, as networks can be sensitive to sample size or sampling effort.

Lets make a comparison between two sites. Say we want to compare the network of a higher elevation site to a lower elevation site (e.g. GCR at 1100m vs. SEC at 500m). We need to first select only observations from those two sites, then add site as a grouping variable in the tod3 custom function from above. There will then be a pivot wider required to get each Site into its own column, which is what bipartite_D3 wants. We can specify how many rows and columns of figures we want using mp = c(rows, cols). In this case we really only have two options, 1 row 2 columns (side by side), or 2 rows, 1 column (stacked). The process other than that is similar to previous figures, adjust the sizes of the whole figure plus the individual sizes. 

```{r}
beesonly %>% #get only observations from the two sites to compare
  filter(Code %in% c("SEC", "MAR")) %>% 
tod3(.,Code) %>% #custom function with site as a grouping variable
  pivot_wider(names_from = Code, values_from = n, values_fill = 0) %>%  #make the additional step necessary to turn this data into a column with counts for each site.
  bipartite_D3(.,
  PrimaryLab = "Plants", #with left label: plants
  SecondaryLab = "Bees", #right label: bees
  #no need for site names as they are already supplied, they could be customized if desired
  MainFigSize = c(2400,1700), #adjusted based on IndivFigSize, note width needed to increase significantly to allow both figures without overlap. 
  IndivFigSize = c(400,1200), #decrease height slightly, not as much needed for smaller networks
  mp = c(1,2)
               )
```
```{r, eval=FALSE, echo=FALSE, fig.cap="A caption", out.width = '100%'}
knitr::include_graphics("marsec.png")
```

```{r, eval=FALSE}
tod3(beesonly,Code) %>% #custom function with site as a grouping variable
  pivot_wider(names_from = Code, values_from = n, values_fill = 0) %>%  #make the additional step necessary to turn this data into a column with counts for each site.
  bipartite_D3(.,
               mp = 2,4)
```

```{r, eval=FALSE}
beesonly %>% 
  filter(Code %in% c("MAR","SEC","KPI")) %>% 
  group_by(associated_taxa,BeeName,Code) %>% 
  summarise(n = n()) %>% 
  pivot_wider(., names_from = Code, values_from = n,values_fill = 0) %>% 
  bipartite_D3(.)
```
```{r, eval = FALSE, echo=FALSE, fig.cap="A caption", out.width = '100%'}
knitr::include_graphics("")
```

```{r, eval=FALSE}
htmlwidgets::saveWidget(marsec, "marsec.html")
```

## Including Plots

You can also embed plots, for example:

```{r, echo=FALSE}
```

Note that the `echo = FALSE` parameter was added to the code chunk to prevent printing of the R code that generated the plot.
